BIO 主要问题在于每当有一个新的客户请求接入时，服务器必须创建一个新的线程处理新接入的客户端链路，
一个线程只能处理一个客户端连接。在高性能服务器应用领域，往往需要面向成千上万个客户端的并发啊连接，
这种方式无法满足高性能、高并发接入的场景。</br>

为了改进一线程一连接模式，后来又演进出了一种通过线程池或者消息队列实现一个或者多个线程处理N个客户端的模型，由于它的底层通讯机制依然时
同步阻塞I/O，所以被称为‘伪异步’，后面尝试一下伪异步是否能够满足我们对高并发高接入的诉求</br>


写代码过程中，完善了对 网络变成下  流的认识：</br>

1、在网络上，readLine()是阻塞模式，也就是说如果readLine()读取不到数据的话，会一直阻塞，而不是返回null，所以如果你想要在while循环后执形相关操作是不可能的，因为while()里面是一个
死循环，一旦读不到数据，它又开始阻塞，因此永远也无法执形while()循环外面的操作，所以应该把操作放在while循环里面。（在我做的即时通讯里，为了能够不断获取服务器返回的消息，就是用这种方法，不断去服务器获取消息
，一旦有就返回。）

2、在while()里面判断readLine()！= null的时候要赋值给一个String，因为如果不为null，那么这时候已经读了一行。如果用while (br.readLine()!=null)，那么下面没法再获取到这一行，所以应该用
while ((line = br.readLine())!=null){}

3、readLine()通过下列字符之一即可认为某行已终止：换行 ('\n')、回车 ('\r') 或回车后直接跟着换行,所以我们在发送数据的时候要再后面加上这些标志符，否则程序会阻塞。而我是直接用下面这种方法：
PrintStream ps = new PrintStream(socket.getOutputStream(), true, "UTF-8");
ps.println()。
ps.println()已经包含换行了，所以不要用print()，若是要就要在后面加上换行符;
 
4、readLine()只有在数据流发生异常或者另一端被close()掉时，才会返回null值。


所以直接使用  println 客户端是直接可以收到数据的，println是会自动在字符后面加上回车换行符的，
`或者你在服务端os.writer("一个乱七八糟的字符串\r\n");`  **当然，使用writer后要跟flush强制将缓存区内容刷新到输出流中**

一开始writer("*****")  然后 flush()  客户端没收到返回数据，以为是输出流的问题。

其实是 readLine() 的规则 见上面描述。